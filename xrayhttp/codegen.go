//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"strings"
)

type Generator struct {
	buf bytes.Buffer
}

func (g *Generator) Printf(s string, args ...interface{}) {
	fmt.Fprintf(&g.buf, s, args...)
}

func (g *Generator) WriteFile(name string) error {
	src, err := g.Format()
	if err != nil {
		return fmt.Errorf("format: %s: %s:\n\n%s\n", name, err, g.Bytes())
	} else if err := ioutil.WriteFile(name, src, 0644); err != nil {
		return err
	}
	return nil
}

func (g *Generator) Bytes() []byte {
	return g.buf.Bytes()
}

func (g *Generator) Format() ([]byte, error) {
	return format.Source(g.Bytes())
}

func generate(interfaces []string, path string) {
	var g Generator
	g.Printf(`// Code generated by codegen.go; DO NOT EDIT

	package xrayhttp

	import "net/http"
	`)

	g.Printf("func wrap(rw *serverResponseTracer) http.ResponseWriter {\n")
	g.Printf("var n uint\n")
	for i, iface := range interfaces {
		g.Printf("if _, ok := rw.rw.(%s); ok {\n n|=0x%x }\n", iface, 1<<uint(i))
	}

	g.Printf("switch n {\n")
	combinations := 1 << uint(len(interfaces))
	values := make([]string, len(interfaces)+1)
	for i := range values {
		values[i] = "rw"
	}
	for i := 0; i < combinations; i++ {
		fields := make([]string, 0, len(interfaces))
		fields = append(fields, "responseWriter")
		for j, iface := range interfaces {
			ok := i&(1<<uint(j)) > 0
			if ok {
				fields = append(fields, iface)
			}
		}
		g.Printf("case 0x%x:\n", i)
		g.Printf(
			"return struct{\n%s\n}{%s}\n",
			strings.Join(fields, "\n"),
			strings.Join(values[:len(fields)], ","),
		)
	}
	g.Printf("}\n")
	g.Printf("panic(\"unreachable\")\n")
	g.Printf("}\n")

	if err := g.WriteFile(path); err != nil {
		log.Fatal(err)
	}
}

func main() {
	generate([]string{
		"http.Flusher",
		"http.CloseNotifier",
		"http.Hijacker",
		"http.Pusher",
	}, "wrap.go")
}
